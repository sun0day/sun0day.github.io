import{_ as e,o as s,c as a,M as n}from"./chunks/framework.0a4c9d35.js";const o="/blog/assets/crx-hmr.35a93252.jpg",t="/blog/assets/create-vite.717f6e77.jpg",F=JSON.parse('{"title":"Rethinking Chrome Extension DX","description":"","frontmatter":{"sidebar":false,"head":[["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:title","content":"Rethinking Chrome Extension DX"}],["meta",{"property":"og:image","content":"https://github.com/sun0day/happy-chrome-extension/assets/102238922/19d5ffe0-2147-4518-97b1-362dff19dba0"}],["meta",{"property":"twitter:image:src","content":"https://github.com/sun0day/happy-chrome-extension/assets/102238922/19d5ffe0-2147-4518-97b1-362dff19dba0"}],["meta",{"property":"og:url","content":"https://sun0day.github.io/blog/crx/rethinking-chrome-extension-dx.html"}],["meta",{"property":"og:description","content":"This article discussed some issues on how to improve the Chrome extension DX"}],["meta",{"name":"twitter:card","content":"summary_large_image"}]]},"headers":[],"relativePath":"crx/rethinking-chrome-extension-dx.md","lastUpdated":1707056422000}'),l={name:"crx/rethinking-chrome-extension-dx.md"},r=n('<h1 id="rethinking-chrome-extension-dx" tabindex="-1">Rethinking Chrome Extension DX <a class="header-anchor" href="#rethinking-chrome-extension-dx" aria-label="Permalink to &quot;Rethinking Chrome Extension DX&quot;">​</a></h1><p>Recently I have been developing an internal Chrome extension via Vite5. In the beginning, I pursued completing this extension MVP as soon as possible, so I didn&#39;t put much focus on the extension engineering. When this extension&#39;s features became more and more complex, I found there was still much room to improve the extension DX. Unfortunately, I see few articles and projects concerning the extension DX issues. This article will discuss some critical issues of Chrome extension DX. I also started a new <a href="https://github.com/sun0day/happy-chrome-extension" target="_blank" rel="noreferrer">GitHub repository</a> to solve these issues, but it still needs a lot of work.</p><h2 id="pain-of-hmr" tabindex="-1">Pain of HMR <a class="header-anchor" href="#pain-of-hmr" aria-label="Permalink to &quot;Pain of HMR&quot;">​</a></h2><p>Currently, you can either manually reload your latest extension as the <a href="https://developer.chrome.com/docs/extensions/get-started/tutorial/hello-world#reload" target="_blank" rel="noreferrer">official document says</a> or reload it internally in scripts via the <a href="https://developer.chrome.com/docs/extensions/reference/api/runtime#method-reload" target="_blank" rel="noreferrer"><code>chrome.runtime.reload</code></a> native API. Frequently manually reloading, especially reloading an extension is painful during development. As to <code>chrome.runtime.reload</code> , it won&#39;t be executed until the extension scripts call it, hence, we need to tell the extension scripts to reload totally or replace the manipulated modules once there is a change on related files.</p><h3 id="assets-loading" tabindex="-1">Assets loading <a class="header-anchor" href="#assets-loading" aria-label="Permalink to &quot;Assets loading&quot;">​</a></h3><p>Unlike loading a normal web page through the network, Chrome loads the extension assets from the local disk. Modern bundler dev servers usually handle asset transformation in memory since it is more efficient. This will block Chrome from querying assets from them.</p><p>One solution is to emit those assets into the extension directory from the servers&#39; memory during runtime. Some other bundlers support to do that, but they can hardly support HMR.</p><h3 id="websocket-limitation" tabindex="-1">WebSocket limitation <a class="header-anchor" href="#websocket-limitation" aria-label="Permalink to &quot;WebSocket limitation&quot;">​</a></h3><p>Modern bundlers usually create a WebSocket channel between the browser and the dev server to handle the HMR communication. However, WebSocket is not allowed to be used in some Chrome extension scripts like <a href="https://developer.chrome.com/docs/extensions/reference/manifest/content-scripts" target="_blank" rel="noreferrer">content scripts</a>.</p><p>On the other hand, WebSocket works in the <a href="https://developer.chrome.com/docs/extensions/reference/manifest/background" target="_blank" rel="noreferrer">background service worker</a>. So we could make the bundler create the channel between the service worker and the dev server. Once there&#39;s a modification on the module, the server first notifies the service worker, and then the service worker tells content scripts to replace the old module via the <a href="https://developer.chrome.com/docs/extensions/develop/concepts/messaging" target="_blank" rel="noreferrer">messaging APIs</a>.</p><h3 id="flow-overview" tabindex="-1">Flow overview <a class="header-anchor" href="#flow-overview" aria-label="Permalink to &quot;Flow overview&quot;">​</a></h3><p>After doing some magic, the Chrome extension HMR process would look like:</p><p><img src="'+o+`" alt="HMR overview"></p><ol><li>Dev server <strong>loads and watches</strong> the source code.</li><li>Dev server <strong>emits</strong> the related assets to the extension directory.</li><li>Chrome <strong>reads</strong> the whole extension directory and <strong>builds</strong> a WebSocket channel between dev server and service worker.</li><li>Dev server <strong>emits</strong> new module to the extension directory when it watches changes, and then <strong>notifies</strong> service worker.</li><li>Service worker <strong>sends</strong> messages about the new module to content script.</li><li>Content script <strong>updates</strong> the new module without reloading.</li></ol><h2 id="advanced-runtime-api" tabindex="-1">Advanced runtime API <a class="header-anchor" href="#advanced-runtime-api" aria-label="Permalink to &quot;Advanced runtime API&quot;">​</a></h2><p>Chrome provides rich <a href="https://developer.chrome.com/docs/extensions/reference/api" target="_blank" rel="noreferrer">native APIs</a> for developers. Those native APIs are flexible and primitive, you can compose them for more advanced features. The issue here is that we need more straightforward APIs to simplify our codes. For example, we can run the following codes in the service worker to retrieve cookies of the matched URL.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/* service worker */</span></span>
<span class="line"><span style="color:#C792EA;">const</span><span style="color:#BABED8;"> cookies </span><span style="color:#89DDFF;">=</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#BABED8;"> chrome</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">cookies</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getAll</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">{</span><span style="color:#BABED8;"> url </span><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre></div><p>If we want to retrieve cookies from the current page context, we need to get cookie stores first, otherwise, we may retrieve cookies from another Chrome window instance.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/* service worker */</span></span>
<span class="line"><span style="color:#BABED8;">chrome</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">runtime</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">onMessage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addListener</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">request</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">sender</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">sendResponse</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// get all cookie stores</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stores</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">chrome</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">cookies</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getAllCookieStores</span><span style="color:#F07178;">()</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// get current page&#39;s cookie store</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">storeId</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">stores</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">find</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">store</span><span style="color:#89DDFF;">)</span><span style="color:#F07178;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">store</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">tabIds</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">includes</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">sender</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">tab</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">id</span><span style="color:#F07178;">))</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">id</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">cookies</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;font-style:italic;">await</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">chrome</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">cookies</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">getAll</span><span style="color:#F07178;">(</span><span style="color:#89DDFF;">{</span><span style="color:#F07178;"> url</span><span style="color:#89DDFF;">:</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">request</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">url</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">storeId</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">}</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// send cookies back to content script</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">sendResponse</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">cookies</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre></div><p>We can encapsulate the cookie retrieve logic into a single function <code>getCookies</code> so that the code could be simpler.</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/* service worker */</span></span>
<span class="line"><span style="color:#BABED8;">chrome</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">runtime</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">onMessage</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">addListener</span><span style="color:#BABED8;">(</span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">request</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">sender</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">sendResponse</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// retrieve cookies by on function</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#C792EA;">const</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">cookies</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#82AAFF;">getCookies</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">request</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">url</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#BABED8;">sender</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">tab</span><span style="color:#89DDFF;">.</span><span style="color:#BABED8;">id</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">    </span><span style="color:#676E95;font-style:italic;">// send cookies back to content script</span></span>
<span class="line"><span style="color:#F07178;">    </span><span style="color:#82AAFF;">sendResponse</span><span style="color:#F07178;">(</span><span style="color:#BABED8;">cookies</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#BABED8;">)</span></span></code></pre></div><p>Encapsulating reusable logic is not only good for making the extension&#39;s codes clean and robust but also for cutting native API understanding costs. I found there are many reusable logics based on the native APIs during my extension development. We can design better APIs for more complex scenarios.</p><h2 id="storage-issues" tabindex="-1">Storage issues <a class="header-anchor" href="#storage-issues" aria-label="Permalink to &quot;Storage issues&quot;">​</a></h2><p><a href="https://developer.chrome.com/docs/extensions/reference/api/storage" target="_blank" rel="noreferrer"><code>chrome.storage</code></a> is designed for storing extension-specific data in the client browser. It&#39;s usually used to share data across extension components, tabs, windows, and even devices. Still, it has several flaws which annoy me.</p><h3 id="data-synchronization" tabindex="-1">Data synchronization <a class="header-anchor" href="#data-synchronization" aria-label="Permalink to &quot;Data synchronization&quot;">​</a></h3><p>It&#39;s common that synchronize data from a storage and react it to UI immediately, especially in some UI frameworks. Unlike other client storages(<code>localStorage</code>, <code>sessionStorage</code>, etc...), Chrome <a href="https://developer.chrome.com/docs/extensions/reference/api/storage#type-StorageArea" target="_blank" rel="noreferrer"><code>StorageArea</code></a> has a different implementation(type definition, &#39;change&#39; event, etc...) with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Storage" target="_blank" rel="noreferrer"><code>Storage</code></a>. Hence, we need to encapsulate a <code>useStorage</code>-style hooks for <code>chrome.storage</code> in a specific UI framework. For example:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/* react hooks</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * @param key {string} stored data key</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * @param defaultValue {T} stored data default value</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * @returns {[T, (nextValue: T) =&gt; void]} returns current stored data value and its setter</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">useChromeStorage</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#BABED8;font-style:italic;">key</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#BABED8;font-style:italic;">defaultValue</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">):</span><span style="color:#BABED8;"> [</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">nextValue</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">void</span><span style="color:#BABED8;">]</span></span></code></pre></div><p>A more low-level API to watch the stored data change can be:</p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/* react hooks</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * @param key {string} stored data key</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * @param listener {(newValue: T) =&gt; void} stored data change callback</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> * @returns void</span></span>
<span class="line"><span style="color:#676E95;font-style:italic;"> */</span></span>
<span class="line"><span style="color:#C792EA;">function</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">listenStorage</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#BABED8;font-style:italic;">key</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">string</span><span style="color:#89DDFF;">,</span><span style="color:#BABED8;"> </span><span style="color:#82AAFF;">listener</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">(</span><span style="color:#BABED8;font-style:italic;">newValue</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">T</span><span style="color:#89DDFF;">)</span><span style="color:#BABED8;"> </span><span style="color:#C792EA;">=&gt;</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">void</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">):</span><span style="color:#BABED8;"> </span><span style="color:#FFCB6B;">void</span></span></code></pre></div><p>This brings us back to the subject of the previous section, &quot;We need more advanced API&quot;.</p><h3 id="data-validation" tabindex="-1">Data validation <a class="header-anchor" href="#data-validation" aria-label="Permalink to &quot;Data validation&quot;">​</a></h3><p>Writing dirty or wrong data to storage happens. Bugs caused by these data(especially stored on the client side) are usually hard to debug and fix. To prevent incorrect data from going to storage unexpectedly, it&#39;s better to validate data strongly before executing the writing operation. We can use some third-party libraries such as <a href="https://www.npmjs.com/package/joi" target="_blank" rel="noreferrer">joi</a> to do the data schema validation.</p><h3 id="data-debug" tabindex="-1">Data debug <a class="header-anchor" href="#data-debug" aria-label="Permalink to &quot;Data debug&quot;">​</a></h3><p>There is no way to see what data are stored in the <code>chrome.storage</code> through the Chrome dev tools unless you log them out to the console. The same issue happens on the exchanged messages between extension scripts. This is not friendly for us to debug codes. We can log the data or message information the same as <a href="https://www.npmjs.com/package/redux-logger" target="_blank" rel="noreferrer"><code>redux-logger</code></a> does. Whenever there is a storage data change or message passing during dev mode, the debug APIs will log.</p><h2 id="stricter-lint" tabindex="-1">Stricter lint <a class="header-anchor" href="#stricter-lint" aria-label="Permalink to &quot;Stricter lint&quot;">​</a></h2><p>We can turn on the ESLint <a href="https://eslint.org/docs/latest/use/configure/language-options" target="_blank" rel="noreferrer"><code>env.webextensions</code></a> in case ESLint unrecognized the native APIs.</p><div class="language-json"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C792EA;">env</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#BABED8;">    </span><span style="color:#89DDFF;">&quot;</span><span style="color:#FFCB6B;">webextensions</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">:</span><span style="color:#BABED8;"> </span><span style="color:#89DDFF;">true</span></span>
<span class="line"><span style="color:#BABED8;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span></code></pre></div><p>Preseting native APIs in ESLint is not enough, we still need more rules to help us find some potential runtime errors. Here are some rules that would help write robust codes.</p><h3 id="no-permission" tabindex="-1"><code>no-permission</code> <a class="header-anchor" href="#no-permission" aria-label="Permalink to &quot;\`no-permission\`&quot;">​</a></h3><p>When we use a native API, we must declare its <a href="https://developer.chrome.com/docs/extensions/reference/permissions-list" target="_blank" rel="noreferrer">permission</a> in the <code>manifest.json</code> first, otherwise, an error will occur when the extension calls this API. To avoid this error during runtime, we can detect it when coding via ESLint.</p><h3 id="version-mismatch" tabindex="-1"><code>version-mismatch</code> <a class="header-anchor" href="#version-mismatch" aria-label="Permalink to &quot;\`version-mismatch\`&quot;">​</a></h3><p>Since manifest V3 is supported generally in Chrome 88 or later, APIs of manifest V2 will be deprecated or refactored gradually. If we use V2 APIs in the V3 context, <code>version-mismatch</code> rule will prompt an ESLint error directly.</p><h3 id="no-unavailable-api" tabindex="-1"><code>no-unavailable-api</code> <a class="header-anchor" href="#no-unavailable-api" aria-label="Permalink to &quot;\`no-unavailable-api\`&quot;">​</a></h3><p>Different contexts have different accessibilities to native APIs. For example, as the <a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#capabilities" target="_blank" rel="noreferrer">document</a> says, we can only use partial native APIs in content scripts. This type of error can be confusing for extension newbie developers, they have to Google it or review the extension document to find out why the native API is <code>undefined</code>.</p><h3 id="no-unhandled-message" tabindex="-1"><code>no-unhandled-message</code> <a class="header-anchor" href="#no-unhandled-message" aria-label="Permalink to &quot;\`no-unhandled-message\`&quot;">​</a></h3><p>When the extension becomes more and more complex, we need to make sure both senders and receivers handle the messages correctly. <code>no-unhandled-message</code> rule will detect whether a message has a handler set on the receiver side in case the message is not handled properly.</p><p>By adding those and more rules, we can write robust codes more easily.</p><h2 id="extension-starter" tabindex="-1">Extension Starter <a class="header-anchor" href="#extension-starter" aria-label="Permalink to &quot;Extension Starter&quot;">​</a></h2><p>The final issue I am gonna talk about is the extension starter. A starter is a tool that can quickly initialize an extension app and manage its project development. A good starter can be flexible for different extension components, scripts, languages and UI frameworks while keeping stable for the bottom bundler, package manager and CI/CD. We can learn that from <a href="https://vitejs.dev/" target="_blank" rel="noreferrer"><code>Vite</code></a> and integrate the powers mentioned above into it.</p><p><img src="`+t+'" alt="create-vite"></p><h2 id="conclusion" tabindex="-1">Conclusion <a class="header-anchor" href="#conclusion" aria-label="Permalink to &quot;Conclusion&quot;">​</a></h2><p>This article talked about some issues and solutions of Chrome extension DX, due to space limitations, there are still quite a lot of issues(such as &quot;message criteria&quot; and &quot;inspect mode&quot;) not mentioned here. What&#39;s weird, I saw very few articles and projects trying to solve these problems. I hope I can find the best practices for them in the future, if you have any ideas about improving Chrome extension DX, you can leave an issue or start a discussion at the repository mentioned above.</p>',52),p=[r];function i(c,d,h,y,m,u){return s(),a("div",null,p)}const g=e(l,[["render",i]]);export{F as __pageData,g as default};
