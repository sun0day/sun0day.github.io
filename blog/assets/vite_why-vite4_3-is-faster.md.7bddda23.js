import{_ as e,o as t,c as o,O as a}from"./chunks/framework.63d7691c.js";const m=JSON.parse('{"title":"Why Vite4.3 is faaaaster?","description":"","frontmatter":{},"headers":[],"relativePath":"vite/why-vite4_3-is-faster.md"}'),r={name:"vite/why-vite4_3-is-faster.md"},s=a('<h1 id="why-vite4-3-is-faaaaster" tabindex="-1">Why Vite4.3 is faaaaster? <a class="header-anchor" href="#why-vite4-3-is-faaaaster" aria-label="Permalink to &quot;Why Vite4.3 is faaaaster?&quot;">​</a></h1><p>Just like <a href="https://github.com/sapphi-red/" target="_blank" rel="noreferrer">@sapphi-red</a> said, Vite4.3 has made an amazing performance improvement than Vite4.2.</p><p><img src="https://user-images.githubusercontent.com/102238922/232652875-2fa5f9a9-17fa-48c8-b3de-4bdf87ae842f.png" alt="perf"></p><p>As a new rookie of the team, I am so glad that I&#39;ve joined this party. To let more people know what we did to make Vite4.3 so fast, we are happy to share the experience.</p><h2 id="smarter-resolve-strategy" tabindex="-1">Smarter resolve strategy <a class="header-anchor" href="#smarter-resolve-strategy" aria-label="Permalink to &quot;Smarter resolve strategy&quot;">​</a></h2><p>Vite resolves all the received urls and paths in order to get the target modules.</p><p>In Vite4.2, there are many <strong>redundant resolve logics and unnecessary module searches</strong>. Vite4.3 makes the resolve logic <strong>simpler</strong>, <strong>stricter</strong> and <strong>more accurate</strong> to reduce calculations and <code>fs</code> calls.</p><h3 id="resolve-simpler" tabindex="-1">Resolve simpler <a class="header-anchor" href="#resolve-simpler" aria-label="Permalink to &quot;Resolve simpler&quot;">​</a></h3><p>Vite4.2 heavily depends on the <a href="https://www.npmjs.com/package/resolve" target="_blank" rel="noreferrer">resolve</a> package to resolve dependency&#39;s <code>package.json</code>, when we looked into the source code of <a href="https://www.npmjs.com/package/resolve" target="_blank" rel="noreferrer">resolve</a>, there were many useless logic while resolving <code>package.json</code>. Vite4.3 abandons <a href="https://www.npmjs.com/package/resolve" target="_blank" rel="noreferrer">resolve</a> and follows the simpler resolve logic: directly check whether <code>package.json</code> exists in the nested parents&#39; directory.</p><h3 id="resolve-stricter" tabindex="-1">Resolve stricter <a class="header-anchor" href="#resolve-stricter" aria-label="Permalink to &quot;Resolve stricter&quot;">​</a></h3><p>Vite has to call the nodejs <code>fs</code> APIs to find the module. But IO is expensive. Vite4.3 narrows the file search and skips searching some special paths in order to reduce the <code>fs</code> calls as much as possible. e.g:</p><ol><li>Since <code>#</code> symbol would not appear in urls and users could control that no <code>#</code> symbol in the source files&#39; paths, Vite4.3 no longer checks paths with <code>#</code> symbol inside user&#39;s own source files but only searches them in the <code>node_modules</code>.</li><li>In unix systems, Vite4.2 checks each absolute path inside the root directory first, it&#39;s fine for most paths, but it would be very likely to fail if the absolute path starts with root. To skip searching <code>/root/root/path-to-file</code> while <code>/root/root</code> doesn&#39;t exist, Vite4.3 judges whether <code>/root/root</code> exists as a directory at the beginning and pre-caches the result.</li><li>When Vite server receives <code>@fs/xxx</code> and <code>@vite/xxx</code>, it would be unnecessary to resolve this urls again. Vite4.3 directly returns the previous cached result instead re-resolving them.</li><li>Vite4.2 uses absolute file paths as the package datas cache keys. That&#39;s not enough since Vite has to traverse the same directory both in <code>pkg/foo/bar</code> and <code>pkg/foo/baz</code>. <br>Vite4.3 uses not only the absolute paths(<code>/root/node_modules/pkg/foo/bar.js</code> &amp; <code>/root/node_modules/pkg/foo/baz.js</code>) but also the traversed directories(<code>/root/node_modules/pkg/foo</code> &amp; <code>/root/node_modules/pkg</code>) as the keys of <code>pkg</code> cache.</li></ol><h3 id="resolve-more-accurate" tabindex="-1">Resolve more accurate <a class="header-anchor" href="#resolve-more-accurate" aria-label="Permalink to &quot;Resolve more accurate&quot;">​</a></h3><p>Vite4.2 recursively resolves the module when the file path is a directory, this would lead to unnecessary calculations repeatedly. Vite4.3 flattens the recursive resolution and applies appropriate resolution to different type paths. It&#39;s also easier to cache some <code>fs</code> calls after flattening.</p><p>Another case is that Vite4.2 looks up <code>package.json</code> of a deep import path inside a single function, e.g when Vite4.2 resolves a file path like <code>a/b/c/d</code>, it first checks whether root <code>a/package.json</code> exists, if not, then finds the nearest <code>package.json</code> in the order <code>a/b/c/package.json</code> -&gt; <code>a/b/package.json</code>, but the fact is that finding root <code>package.json</code> and nearest <code>package.json</code> should be handled separately since they are needed in different resolve contexts. Vite4.3 splits the root <code>package.json</code> and nearest <code>package.json</code> resolution in two parts so that they won&#39;t mix with each other.</p><h2 id="non-blocking-tasks" tabindex="-1">Non-blocking tasks <a class="header-anchor" href="#non-blocking-tasks" aria-label="Permalink to &quot;Non-blocking tasks&quot;">​</a></h2><p>As an on-demand service, Vite dev server can be started without all the stuff being ready.</p><h3 id="non-blocking-tsconfig-parsing" tabindex="-1">Non-blocking <code>tsconfig</code> parsing <a class="header-anchor" href="#non-blocking-tsconfig-parsing" aria-label="Permalink to &quot;Non-blocking `tsconfig` parsing&quot;">​</a></h3><p>Vite server needs <code>tsconfig</code> data when pre-bundling <code>ts</code> or <code>tsx</code>.</p><p>Vite4.2 waits <code>tsconfig</code> data being parsed in the plugin hook <code>configResolved</code> before server starts up. In fact, page request could visit the server once server starts up without <code>tsconfig</code> data is ready even though the request might need to wait the <code>tsconfig</code> parsing later.</p><p>Vite4.3 inits <code>tsconfig</code> parsing before server starts up, but the server won&#39;t wait for it. The parsing process runs in the background. Once a <code>ts</code>-related request comes in, it will have to wait until the <code>tsconfig</code> parsing finished.</p><h3 id="non-blocking-file-processing" tabindex="-1">Non-blocking file processing <a class="header-anchor" href="#non-blocking-file-processing" aria-label="Permalink to &quot;Non-blocking file processing&quot;">​</a></h3><p>There are plenty of <code>fs</code> calls in Vite, some of them are synchronous. These synchronous <code>fs</code> calls may block the main thread. Vite4.3 changes them to asynchronous. Also it&#39;s easier to parallelize the asynchronous functions. One thing about asynchronous functions you should care about is that there might be many <code>Promise</code> objects to be released after they are resolved. Thanks to the smarter resolve strategy, the cost of releasing <code>fs</code>-<code>Promise</code> objects is much less.</p><h2 id="hmr-cache" tabindex="-1">HMR cache <a class="header-anchor" href="#hmr-cache" aria-label="Permalink to &quot;HMR cache&quot;">​</a></h2><p>Consider a simple dependency chain <code>root &lt;- B &lt;- A</code>, when <code>A</code> is edited, HMR will propagate from <code>A</code> to <code>root</code>. Most of the time, users edit single file once a time. In some special cases like <code>git checkout branch</code>, there might be plenty of files change at the same time, this will cause duplicate HMR propagation from <code>B</code> to <code>root</code>. In Vite4.3, we cache the files in each HMR propagation chain so that they could be skipped in other HMR propagation chains.</p><h2 id="parallelization" tabindex="-1">Parallelization <a class="header-anchor" href="#parallelization" aria-label="Permalink to &quot;Parallelization&quot;">​</a></h2><p>Parallelization is always a good choice for better performance. In Vite4.3, we parallelized some core features includes <a href="https://github.com/vitejs/vite/pull/12754/files" target="_blank" rel="noreferrer">imports analysis</a>, <a href="https://github.com/vitejs/vite/pull/12869/files" target="_blank" rel="noreferrer">extract deps&#39; exports</a>, <a href="https://github.com/vitejs/vite/pull/12619/files" target="_blank" rel="noreferrer">resolve module urls</a> and <a href="https://github.com/vitejs/vite/pull/12609/files" target="_blank" rel="noreferrer">run bulk optimizers</a>. There is indeed an impressive improvement after parallelization.</p><h2 id="javascript-optimization" tabindex="-1">Javascript optimization <a class="header-anchor" href="#javascript-optimization" aria-label="Permalink to &quot;Javascript optimization&quot;">​</a></h2><p>Do not miss programming language optimization. Some interesting javascript optimization cases in Vite4.3:</p><h3 id="substitute-yield-with-callback" tabindex="-1">Substitute <code>*yield</code> with callback <a class="header-anchor" href="#substitute-yield-with-callback" aria-label="Permalink to &quot;Substitute `*yield` with callback&quot;">​</a></h3><p>Vite uses <a href="https://github.com/dominikg/tsconfck" target="_blank" rel="noreferrer">tsconfck</a>(by <a href="https://github.com/dominikg" target="_blank" rel="noreferrer">@dominikg</a>) to find and parse <code>tsconfig</code> files. <a href="https://github.com/dominikg/tsconfck" target="_blank" rel="noreferrer">tsconfck</a> used to walk the target directory via <code>*yield</code>, one disadvantage of generator is that it needs more memory spaces to store its <code>Generator</code> object and there would be plenty of generator context switches in the runtime. So <a href="https://github.com/dominikg" target="_blank" rel="noreferrer">@dominikg</a> substituted <code>*yield</code> with callback in the core since v2.1.1.</p><p>Check more details <a href="https://github.com/dominikg/tsconfck/pull/84/files" target="_blank" rel="noreferrer">here</a>.</p><h3 id="substitute-startswith-endswith-with" tabindex="-1">Substitute <code>startsWith</code> &amp; <code>endsWith</code> with <code>===</code> <a class="header-anchor" href="#substitute-startswith-endswith-with" aria-label="Permalink to &quot;Substitute `startsWith` &amp; `endsWith` with `===`&quot;">​</a></h3><p>We also noticed that Vite4.2 uses <code>startsWith</code> and <code>endsWith</code> to check the heading and trailing <code>&#39;/&#39;</code> in hot urls. We compared <code>str.startsWith(&#39;x&#39;)</code>&#39;s and <code>str[0] === &#39;x&#39;</code>&#39;s execution benchmarks and found <code>===</code> was about ~20% faster than <code>startsWith</code>. And <code>endsWith</code> was about ~60% slower than <code>===</code> in the meantime.</p><h3 id="avoid-recreating-regular-expression" tabindex="-1">Avoid recreating regular expression <a class="header-anchor" href="#avoid-recreating-regular-expression" aria-label="Permalink to &quot;Avoid recreating regular expression&quot;">​</a></h3><p>Vite needs a lot of regular expressions to match strings, most of them are static, it would be much better to only use their singletons. Vite4.3 hoists regular expressions so they could be reused.</p><h2 id="inch-by-inch" tabindex="-1">Inch by inch <a class="header-anchor" href="#inch-by-inch" aria-label="Permalink to &quot;Inch by inch&quot;">​</a></h2><blockquote><p>Rome wasn&#39;t built in a day</p></blockquote><p>So was Vite4.3.</p><p>We put a lot of big or small efforts to optimize the performance as much as possible. And finally we made it!</p><p>This article shows the main ideas about how we optimize Vite4.3. If you are interesting in more of what we did, see <a href="https://github.com/vitejs/vite/blob/main/packages/vite/CHANGELOG.md" target="_blank" rel="noreferrer">CHANGELOG</a> here.</p><p><strong>Looking forward to sharing with us your Vite4.3 stories.</strong></p><h2 id="benchmark-ecosystem" tabindex="-1">Benchmark ecosystem <a class="header-anchor" href="#benchmark-ecosystem" aria-label="Permalink to &quot;Benchmark ecosystem&quot;">​</a></h2><ul><li><a href="https://github.com/vitejs/vite-benchmark" target="_blank" rel="noreferrer">vite-benchmark</a>(by <a href="https://github.com/fi3ework" target="_blank" rel="noreferrer">@fi3ework</a>): vite uses this repo to test every commit&#39;s benchmark, if you are developing a large project with vite, we are happy to test your repo for a more comprehensively performance.</li><li><a href="https://github.com/antfu/vite-plugin-inspect" target="_blank" rel="noreferrer">vite-plugin-inspect</a>(by <a href="https://github.com/antfu" target="_blank" rel="noreferrer">@antfu</a>): vite-plugin-inspect supports to show the plugins&#39; hook time since v0.7.20, and there will be more benchmark graphs in the future, let us know what you need.</li><li><a href="https://github.com/bluwy/vite-plugin-warmup" target="_blank" rel="noreferrer">vite-plugin-warmup</a>(by <a href="https://github.com/bluwy" target="_blank" rel="noreferrer">@bluwy</a>): warm up your vite server, speed up the page loading!</li></ul>',44),i=[s];function n(c,l,h,d,p,u){return t(),o("div",null,i)}const f=e(r,[["render",n]]);export{m as __pageData,f as default};
